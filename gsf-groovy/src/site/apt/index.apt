GSF-Groovy

  The gsf-groovy project is a showcase of how a scripting language can be used to developer websites faster while still 
  allowing for 
  
Features
  
  * Make use of FatWire Content Server rendering engine to deliver web pages.
  
  * As Content Server is closed and the integration point are elements, the scripting language must to invoked from elements.
  
  * Language must integrated with java, in a servlet container.
  
  * Deployment of changes should be require application server restart, both to speedy development as maintaining state.
  
  * Language must be elegant and have a short learning curve.
  
  * The lanhuage must be well suite to implement businses logic. Writing text output is of less concern as this is handled well with JSP.
  
  
  Groovy was chosen because it integrates well with java, and has a java-like syntax, and it can be dynamically reloaded.
  
  
Action

  The groovy integration makes use of the Action framework. An Action is a class the implements business logic. The Action is either loaded by the Controller or the 
  \<p:page\> jsp tag. The Action framework is based on the {{{http://en.wikipedia.org/wiki/Command_pattern}command pattern}}. It's role is to provide Model data 
  as defined in the {{{http://en.wikipedia.org/wiki/Model-view-controller}MVC deisgn pattern}}.
 
  The Action interface defines one method: <public void handleRequest(ICS ics)>.

  The Action is part of the <Controller>. It is invoked by the <Controller>. It's role is to provide data, and not the select a View. 
  
  Below is a very simple hello-world like Action implementation, it just prints 'groovy was here' to the screen. 

--------------

import COM.FutureTense.Interfaces.ICS

class GTLayout implements Action {

	public void handleRequest(ICS ics){

		ics.StreamText("<h1>groovy was here</h1>")

	}
}

----------------
  
  A Content Server web site is build by many different Action classes, as well as Templates and CSElements. The discovery of elements and Template is well know, 
  for Actions a special discovery mechanism is implemented.
  
  The Action is discovered by an <ActionLocator> class that is responsible for instantiating and configuring up the right Action based on the current request
  or JSP page. This means that the ActionLocator discovers the ICS object in assigns the correct Action to the current request, based on whatever data is available
  on that object. This could be a special variable name, the current element name, or a name provided by the jsp tag \<p:page\>. 
  The Action locator is also responsible for injecting the declared dependencies on the Action. This can be done via the spring framework and/or via
  @InjectForRequest and @Mapping annotations on the class.
  

@InjectForRequest

  A public field annotated with @InjectForRequest on an Action class will be injected by the ActionLocator. For instance a TemplateAssetAccess service can be injected. 
  The developer does not need to know how the TemplateAssetAccess was created, the framework provide it to him.
  
  Here is an example:

------

    @InjectForRequest public TemplateAssetAccess assetDao;
    @InjectForRequest public Model model;
    @InjectForRequest public ICS ics;

-------  

  Depending on how the ActionLocator is configured it might be <double dipping>; depencency injection can happen first by the spring framework and secondly with InjectForRequest. 
  All the servcies that are not bound to the request lifecycle could be injected by spring and services that need access to ICS, like asset api calls, are injected by the InjectForRequest annotation.
  
* ICS and Model are special.

  There are two objects that are special for the @InjectForRequest annotation handling framework; the ICS object and the Model object. 
  The ICS object can be made available as a class field, so it can be used in methods on the Action implementation classes without passing the ICS object 
  explicitly as a method parameter when the method is called from the <handleRequest> method.

  The Model object is an output field for the action. A Model is a name/value pairs data structure. The Action can populate the model data so it can be used by the jsp element, for instance to 
  display the asset data, or write a link to another asset. The Model data is copied by the \<p:page\> tag to the jsp page scope, and by that means made avialable to the jsp developer.


@Mapping

  The is a special form of dependency injection, and this is not for services but for CSElement and Template Mapping data. Where in traditional Template code the 
  \<render:lookup/\> tag is used to retrieve  Template and CSElement Mapping values, now the @Mapping annotation can be used. The field object type can be of
  3 classes, a String, a AssetId or an AssetName, depending on the Mapping type, or MappingValue independant of the type.
  
-----
	@Mapping("Detail") public String detail
	@Mapping("StyleSheetReco") public AssetId stylesheetId;
	@Mapping("Filter") public AssetName filter
	@Mapping("Foo") public MappingValue bar
------
  
  Mapping annotation also accepts a match attribute, for instance <@Mapping(value="ImageFileAttrName", match=Match.right)>,
  analogous to match=":x" or match="x:" in the render:lookup tag. The match=Match.right is to get the right side of the Mapping for ImageFileAttrName, 
  as Asset (Type:Name) mapping with value Media_A:FSII_ImageFile. In this case FSII_ImageFile is injected. An alternative for this construct would be  
  <@Mapping("ImageFileAttrName") public AssetName ImageFileAttrName>. In this case both the Media_A and the FSII_ImageFile are accessable.
  The action code would then be ImageFileAttrName.getName(); The latter construct is a more natural style as it is close to the ContentServer mapping styles.
  
  
Model

  The Model class is the name/value pairs data structure to transport data from the Action to the element, analogous to from Controller to View in MVC frameworks. The names must be  Strings
  and the value can be any object. This can be a string, a collection of strings, or any object that tje JSP expression language can process, like Maps and java beans.
  
  The model has three important methods:

-------

    public void add(String key, Object value) {... }
    public void add(String key, Object... value) {... }
    public void list(String key, Object value) {... }
    
---------    
   
   The first add method just adds a name/value pair to the model, replacing the current value if it already existed.
   
   The second method, with the value array, is adding all the values as a Collection to the key name.
   
   The third method, list, adds the current key/value pair to the Collection idenfied by key, or creates a new Collection if one did not exists or was not a Collection.


Groovy sample

  
  The {{{./jsp/cs_deployed/AssetApiTest.jsp.txt}Asset Api test}} file shows a jsp file that uses the  
  {{{./gsf-groovy/test/AssetApi.groovy}Groovy Action}} to load and display an asset.

------------

<%@ taglib prefix="cs" uri="futuretense_cs/ftcs1_0.tld"
%><%@ taglib prefix="p" uri="http://gst.fatwire.com/foundation/tags/p"
%><cs:ftcs>
  <p:page action="test/AssetApi"> 
  Hello World.
  </p:page>
</cs:ftcs>

------------

   The jsp page starts of the the traditional \<cs:ftcs\> tag, followed by the \<p:page\> tag. Inside the p:page tag should the normal jsp code placed.
   The ftcs tag sets the ics variable on the jsp page, as well as some output stream handling.
   The p:page tags discovers the Action based on the <action> attribute value via the spring configured ActionLocator. The Action can be implemented in java or 
   as in this example in Groovy.

   As you can see, the Grrovy files look a lot like a normal java class. It start with package declaration, imports, javadoc and then the class definition.   
   Inside the handleRequest method is the business logic defined. In this example the logic is simple, it finds the current asset based on <c/cid> ics variables,
   and prints the AssetData  via the DebugHelper class directly to the output stream. Thsi direct writing to the stream is not a textbook example of best practise, as this should be done 
   in the jsp page, but it does show a simple example. Also the error handling is rudimentary and too simple for real applications.
   
-------

package test;

import COM.FutureTense.Interfaces.ICS

import com.fatwire.assetapi.common.AssetAccessException
import com.fatwire.assetapi.data.AssetData
import com.fatwire.assetapi.data.AssetId
import com.fatwire.gst.foundation.DebugHelper
import com.fatwire.gst.foundation.controller.action.Action
import com.fatwire.gst.foundation.facade.assetapi.AssetDataUtils
import com.fatwire.gst.foundation.facade.assetapi.AssetIdUtils
import com.openmarket.xcelerate.asset.AssetIdImpl

/**
 * Class that implements a call to AssetAPI and prints the AssetData.
 *
 */
public class AssetApi implements Action {

    @Override
    public void handleRequest(ICS ics) {
        AssetId id= AssetIdUtils.currentId(ics);

        long t = java.lang.System.nanoTime()
        AssetData data =AssetDataUtils.getAssetData(ics,id)
        long t2 = java.lang.System.nanoTime()

        ics.StreamText("Reading asset took " +DebugHelper.nanoToHuman(t2-t) + ".<br/>");
        String s;
        try {
            s = DebugHelper.printAsset(data);
            ics.StreamText("<pre>");
            ics.StreamText(s);
            ics.StreamText("</pre>");
        } catch (AssetAccessException e) {
            e.printStackTrace();
        }
    }
}

-------------

Code samples

 Below are some more realistic code samples. The following code samples are for a copied version of FirstSiteII. The SiteLauncher tools was used to copy the Template, SiteEntry, CSElement and Page assettypes from the FSII site to a new site called Test, with prefix GT. The other assettypes
 were shared.
  
  
  JSP {{{./jsp/cs_deployed/GTLayout.jsp.txt}ayout template}}
  groovy {{{./gsf-groovy/GTLayout.groovy}GTLayout}}
  
  JSP {{{./jsp/cs_deployed/AdvCols/GTStyleSheetResolver.jsp.txt}StyleSheetResolver}}
  groovy {{{./gsf-groovy/advcol/GTStyleSheetResolver.groovy}StyleSheetResolver}}
  
  JSP {{{./jsp/cs_deployed/GTCommon/Locale/ExecuteFilter.jsp.txt}ExecuteFilter}}
  groovy {{{./gsf-groovy/gtcommon/locale/ExecuteFilter.groovy}ExecuteFilter}}
  
  JSP {{{./jsp/cs_deployed/Media_C/GTDetail.jsp.txt}Media_C Detail}} and 
  JSP {{{./jsp/cs_deployed/Media_C/GTSummary.jsp.txt}Media_C Summary}} making both use of
  groovy {{{./gsf-groovy/mediac/GTDetail.groovy}Media_C Detail}}

  JSP {{{./jsp/cs_deployed/Page/GTTopNav.jsp.txt}Page Top Nav}}
  groovy {{{./gsf-groovy/page/GTTopNav.groovy}Page top nav}}
  
  JSP {{{./jsp/cs_deployed/Product_P/GTDetail.jsp.txt}Product Parent Detail}}
  groovy {{{./gsf-groovy/productp/GTDetail.groovy}Product Parent Detail}}


IncludeService

  GSF has a way to set up the View layer to make calls to Template, CSElement and SiteEntries from the Action. This is done with help of the IncludeService.
  This service is a facade over CallTemplate, CallElement, render:satellitepage and render:contentserver. In the Action you set up the various <includes>
  and give them a name so they can be identified in the template. The name is similar to the slotname in CallTemplate.
  
  In the jsp this is written to include a block. As you can see the jsp developer does not need to know if this is a CSElement or Template, or if it should 
  be called as a pagelet, embedded or as an element. That is all done in the Action.

---------
<cs:ftcs>
  <p:page action="GTLayout">
    <head>
    <p:include name="Head" />
    </head>
    [ rest of the page truncated for clarity]
  </p:page>
</cs:ftcs>

--------
  
  In the groovy Action the code is as follows:

-------
public void handleRequest(ICS ics){


	//global call, include the element execution here, by invoking include(ics)
	includeService.element ("Filter", filter.getName()).include ics

	AssetId pageId = assetDao.createAssetId("Page",ics.GetVar("p"))

	includeService.template("StyleSheetSlot", stylesheetId ,styleSheetResolver).element()

	includeService.template("Head",assetDao.currentId(),head); // p and locale are copied as part of pagecriteria

	includeService.template("TopNav", pageId,topNav)

	includeService.template("BannerSlot", bannerList,bannerTemplate).element()

	includeService.template("SideNav", assetDao.currentId(),sideNav).element()

	includeService.template("Detail", assetDao.currentId(),detail).pagelet()

	includeService.template("BottomNav", pageId,bottomNav).embedded()


}
---------
    As you can see one CallElement is issued immediately. This is because that element is changing the current state and needs to be called 
    inline. With better java and groovy support we suspect that the use of CSElements to execute business logic is drasticly reduced.
    
    The other include calls are all for CallTemplate. The first argument is always the name of the slot. This name is used to reference the block in the
    jsp element. As Template are used to render an asset, the second argument is a assetId, and the third the template name. Other arguments are implictly copied if they are part
    of the page criteria, for instance <p> and <locale>. the methods <element()>, <pagelet()> and <embedded()> indicate the call Style.
    
    Important is the remember that all CallTemplate calls are done in the jsp executing and not here. This allows for the jsp page code to move 
    te blocks around without impacting the business logic.


Links and Blobs

  For links and blobs the is also added support. There are two classes that help with populating image and anchors tags in the jsp element. Here is a 
  sample for the FSII Layout and Media_C/Detail template.

------
Img img = new Img();
img.setSrc (ics.GetProperty("ft.cgipath") + ics.GetVar("site") +"/images/PoweredByFatWire.gif") 
img.setAlt ("Powered by FatWire Software")

model.add("PoweredBy",img)

BlobUriBuilder ub = new BlobUriBuilder(asset.asBlob(ImageFileAttrName));
ub.mimeType(asset.asString(ImageMimeTypeAttrName))
Img img = new Img();
img.setSrc(ub.toURI(ics));
img.setWidth asset.asString(ImageWidthAttrName)
img.setHeight asset.asString(ImageHeightAttrName)
String alt = asset.asString(AltTextAttrName);
if(StringUtils.isBlank(alt)){
	alt="Content Server Image"
}
img.setAlt alt
model.add("image",img);

-------

  and in the jsp element is written:

------
<div id="PoweredBy">
	<img src="${PoweredBy.src}" alt="${PoweredBy.alt}" />
</div>
<c:if test="${!empty image.src}">
	<img src="<string:stream value="${image.src}" />" class="ImageDetail" width="${image.width}"
	height="${image.height}" alt="${image.alt}" />
</c:if>

------
  
Configuration

  The Action framework and possibly also the action are configured via Spring framework. In the {{{./web.xml.txt}web.xml}}
  file is a spring context file added, 
   
   {{{./gsfApplicationContext.xml.txt}Spring context file}}
   
